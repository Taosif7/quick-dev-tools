<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JSON HTML/Base64 Previewer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Cleaner scrollbars */
    .scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
    .scrollbar::-webkit-scrollbar-track { background: #f1f1f1; }
    .scrollbar::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px; }
    .scrollbar::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
  </style>
</head>

<body class="h-screen w-screen p-0 bg-white flex flex-col overflow-hidden text-gray-800">

  <!-- Header -->
  <div class="px-4 md:px-6 py-2 border-b border-gray-200 shrink-0">
    <h1 class="text-lg font-semibold">JSON HTML/Base64 Previewer</h1>
    <p class="text-[11px] text-gray-500 mt-0.5 hidden md:block">
      Paste a response JSON, choose keys (supports dot-path like <span class="font-mono">data.invoicePdfContent</span>),
      and previews will appear in the carousel below.
    </p>
  </div>

  <!-- Controls -->
  <div class="flex flex-col gap-2 px-4 md:px-6 py-2 border-b border-gray-200 shrink-0">
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-2 items-end">
      <div class="lg:col-span-2">
        <label for="jsonInput" class="text-sm font-medium">Response JSON</label>
        <textarea
          id="jsonInput"
          class="w-full mt-1 rounded border border-gray-300 px-3 py-2 font-mono text-xs focus:outline-none focus:ring-2 focus:ring-blue-500 h-20 resize-none scrollbar"
          placeholder='Paste JSON. Example: { "htmlContent": "...", "invoicePdfContent": "..." }'
          autocomplete="off"
          spellcheck="false"
        ></textarea>
      </div>

      <div>
        <label for="keysInput" class="text-sm font-medium">Keys to preview</label>
        <textarea
          id="keysInput"
          class="w-full mt-1 rounded border border-gray-300 px-3 py-2 font-mono text-xs focus:outline-none focus:ring-2 focus:ring-blue-500 h-20 resize-none scrollbar"
          placeholder="One per line or comma-separated&#10;htmlContent&#10;data.invoicePdfContent&#10;pdfContent"
          autocomplete="off"
          spellcheck="false"
        ></textarea>
      </div>
    </div>

    <div class="flex items-center gap-2 flex-wrap">
      <button
        id="parseBtn"
        class="inline-flex items-center rounded bg-blue-600 text-white text-sm font-medium px-3 py-1.5 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors"
      >
        Parse & Preview
      </button>
      <button
        id="clearBtn"
        class="inline-flex items-center rounded bg-gray-100 text-gray-900 text-sm font-medium px-3 py-1.5 hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-300 transition-colors"
      >
        Clear
      </button>

      <span id="jsonError" class="text-red-600 text-sm hidden"></span>
    </div>
  </div>

  <!-- Preview Carousel -->
  <div class="flex-1 min-h-0 overflow-hidden">

    <div class="flex-1 min-h-0 overflow-hidden">
      <div
        id="previewCarousel"
        class="h-full flex gap-4 p-4 md:px-6 overflow-x-auto overflow-y-hidden snap-x snap-mandatory scrollbar"
      >
        <div id="emptyState" class="min-w-full h-full flex items-center justify-center text-gray-400 text-sm">
          Add keys and click “Parse & Preview”.
        </div>
      </div>
    </div>
  </div>


  <!-- Fullscreen Modal -->
  <div id="fullscreenModal" class="fixed inset-0 z-50 hidden">
    <div id="fullscreenBackdrop" class="absolute inset-0 bg-black/50"></div>
    <div class="absolute inset-0 p-3 md:p-6 flex flex-col">
      <div class="bg-white rounded-xl shadow-lg border border-gray-200 flex flex-col h-full overflow-hidden">
        <div class="px-4 py-3 border-b border-gray-200 flex items-center justify-between gap-3">
          <div class="min-w-0">
            <div id="fullscreenTitle" class="text-sm font-semibold truncate"></div>
            <div id="fullscreenSubtitle" class="text-xs text-gray-500 truncate"></div>
          </div>
          <button id="fullscreenClose" class="shrink-0 rounded-lg border border-gray-300 bg-white px-3 py-1.5 text-xs font-medium hover:bg-gray-50 active:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-300">
            Close
          </button>
        </div>
        <div id="fullscreenBody" class="flex-1 overflow-auto bg-gray-50 p-3 md:p-4 scrollbar"></div>
      </div>
    </div>
  </div>


<script>
  // -------------------------
  // Helpers: path resolution
  // -------------------------
  function getByPath(obj, path) {
    if (!obj || !path) return undefined;
    // Support dot paths and bracket indices: a.b[0].c
    const parts = [];
    path.split('.').forEach(chunk => {
      const re = /(\w+)|\[(\d+)\]/g;
      let m;
      while ((m = re.exec(chunk)) !== null) {
        parts.push(m[1] ?? Number(m[2]));
      }
    });
    return parts.reduce((acc, key) => (acc == null ? undefined : acc[key]), obj);
  }

  function parseKeys(raw) {
    return raw
      .split(/[,\n\r]+/)
      .map(s => s.trim())
      .filter(Boolean);
  }

  // -------------------------
  // Helpers: base64 detection
  // -------------------------
  function extractDataUri(input) {
    const trimmed = (input || "").trim();
    if (!trimmed.startsWith("data:")) return null;
    const commaIndex = trimmed.indexOf(",");
    if (commaIndex === -1) return null;
    const meta = trimmed.slice(5, commaIndex); // after "data:"
    const payload = trimmed.slice(commaIndex + 1).replace(/\s+/g, "");
    return { meta, payload };
  }

  function looksLikeBase64(str) {
    if (!str) return false;
    const s = str.replace(/\s+/g, "");
    if (s.length < 32) return false;
    // Must be multiple of 4 (common base64 characteristic)
    if (s.length % 4 !== 0) return false;
    // Base64 charset
    return /^[A-Za-z0-9+/=]+$/.test(s);
  }

  function decodeBase64ToUint8Array(base64) {
    try {
      const binaryString = window.atob(base64);
      const len = binaryString.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
      return bytes;
    } catch (e) {
      return null;
    }
  }

  function bytesStartWith(bytes, ascii) {
    if (!bytes || bytes.length < ascii.length) return false;
    for (let i = 0; i < ascii.length; i++) {
      if (bytes[i] !== ascii.charCodeAt(i)) return false;
    }
    return true;
  }

  function decodeBytesToText(bytes) {
    try {
      const decoder = new TextDecoder("utf-8", { fatal: false });
      return decoder.decode(bytes);
    } catch {
      return "";
    }
  }

  function detectPayload(str) {
    if (typeof str !== "string") return { kind: "unsupported", reason: "Not a string" };
    const trimmed = str.trim();
    if (!trimmed) return { kind: "empty" };

    // Plain HTML (not base64)
    const maybeHtmlPlain =
      trimmed.startsWith("<") ||
      /<!doctype\s+html/i.test(trimmed) ||
      /<html[\s>]/i.test(trimmed);

    if (maybeHtmlPlain) {
      return { kind: "html", mode: "plain", html: trimmed };
    }

    // Data URI
    const dataUri = extractDataUri(trimmed);
    if (dataUri) {
      const meta = dataUri.meta.toLowerCase();
      const payload = dataUri.payload;

      if (meta.includes(";base64")) {
        const bytes = decodeBase64ToUint8Array(payload);
        if (!bytes) return { kind: "unknown", mode: "data-uri", reason: "Invalid base64" };

        if (meta.includes("application/pdf") || bytesStartWith(bytes, "%PDF")) {
          return { kind: "pdf", mode: "base64", bytes };
        }

        // Try HTML text
        const text = decodeBytesToText(bytes);
        if (/<html[\s>]/i.test(text) || /<!doctype\s+html/i.test(text) || /<body[\s>]/i.test(text)) {
          return { kind: "html", mode: "base64", html: text };
        }

        return { kind: "bytes", mode: "base64", bytes, textPreview: text.slice(0, 4000) };
      }

      // Non-base64 data URIs aren't supported here
      return { kind: "unknown", mode: "data-uri", reason: "Data URI is not base64" };
    }

    // Raw base64 (try decode)
    const compact = trimmed.replace(/\s+/g, "");
    if (looksLikeBase64(compact)) {
      const bytes = decodeBase64ToUint8Array(compact);
      if (!bytes) return { kind: "unknown", mode: "base64", reason: "Invalid base64" };

      if (bytesStartWith(bytes, "%PDF")) {
        return { kind: "pdf", mode: "base64", bytes };
      }

      const text = decodeBytesToText(bytes);
      if (/<html[\s>]/i.test(text) || /<!doctype\s+html/i.test(text) || /<body[\s>]/i.test(text)) {
        return { kind: "html", mode: "base64", html: text };
      }

      return { kind: "text", mode: "base64", text, textPreview: text.slice(0, 4000) };
    }

    // Fallback: plain text
    return { kind: "text", mode: "plain", text: trimmed, textPreview: trimmed.slice(0, 4000) };
  }

  // -------------------------
  // UI State
  // -------------------------
  const els = {
    jsonInput: document.getElementById("jsonInput"),
    keysInput: document.getElementById("keysInput"),
    parseBtn: document.getElementById("parseBtn"),
    clearBtn: document.getElementById("clearBtn"),
    jsonError: document.getElementById("jsonError"),
    carousel: document.getElementById("previewCarousel"),
    emptyState: document.getElementById("emptyState"),
    fullscreenModal: document.getElementById("fullscreenModal"),
    fullscreenBackdrop: document.getElementById("fullscreenBackdrop"),
    fullscreenClose: document.getElementById("fullscreenClose"),
    fullscreenTitle: document.getElementById("fullscreenTitle"),
    fullscreenSubtitle: document.getElementById("fullscreenSubtitle"),
    fullscreenBody: document.getElementById("fullscreenBody"),  };

  let activeBlobUrls = [];


  // -------------------------
  // Fullscreen modal
  // -------------------------
  function buildNodeFromFullscreenSpec(spec) {
    if (!spec) return document.createTextNode("");
    if (spec.type === "html") {
      const iframe = makeIframe();
      iframe.srcdoc = spec.srcdoc || "";
      return iframe;
    }
    if (spec.type === "pdf") {
      const iframe = makeIframe();
      iframe.removeAttribute("sandbox");
      iframe.src = spec.src || "";
      return iframe;
    }
    if (spec.type === "text") {
      return makePre(spec.text || "");
    }
    // fallback
    return makePre(spec.text || "");
  }

  function openFullscreen(spec) {
    els.fullscreenTitle.textContent = spec.title || "";
    els.fullscreenSubtitle.textContent = spec.subtitle || "";
    els.fullscreenBody.innerHTML = "";
    const node = buildNodeFromFullscreenSpec(spec);
    // Make it truly full height inside modal
    if (node && node.tagName === "IFRAME") {
      node.className = "w-full h-[80vh] bg-white rounded-lg border border-gray-200";
    }
    els.fullscreenBody.appendChild(node);
    els.fullscreenModal.classList.remove("hidden");
    document.body.classList.add("overflow-hidden");
  }

  function closeFullscreen() {
    els.fullscreenModal.classList.add("hidden");
    els.fullscreenBody.innerHTML = "";
    document.body.classList.remove("overflow-hidden");
  }


  function revokeAllBlobs() {
    activeBlobUrls.forEach(url => URL.revokeObjectURL(url));
    activeBlobUrls = [];
  }

  function setError(msg) {
    if (!msg) {
      els.jsonError.classList.add("hidden");
      els.jsonError.textContent = "";
      return;
    }
    els.jsonError.textContent = msg;
    els.jsonError.classList.remove("hidden");
  }

  function clearCarousel() {
    revokeAllBlobs();
    els.carousel.innerHTML = "";
    const empty = document.createElement("div");
    empty.id = "emptyState";
    empty.className = "min-w-full h-full flex items-center justify-center text-gray-400 text-sm";
    empty.textContent = "Add keys and click “Parse & Preview”.";
    els.carousel.appendChild(empty);  }

  function createCard({ title, subtitle, contentNode, fullscreenSpec }) {
    const card = document.createElement("div");
    card.className = [
      "snap-start",
      "shrink-0",
      "w-full",
      "md:w-1/2",
      "min-w-[600px]",
      "max-w-[900px]",
      "rounded-xl",
      "border",
      "border-gray-200",
      "bg-white",
      "shadow-sm",
      "flex",
      "flex-col",
      "min-h-0"
    ].join(" ");

    const header = document.createElement("div");
    header.className = "px-4 py-3 border-b border-gray-200 flex items-start justify-between gap-3";

    const left = document.createElement("div");
    left.className = "min-w-0";

    const h = document.createElement("div");
    h.className = "text-sm font-semibold truncate";
    h.textContent = title;

    const sub = document.createElement("div");
    sub.className = "text-xs text-gray-500 mt-0.5 truncate";
    sub.textContent = subtitle || "";

    left.appendChild(h);
    left.appendChild(sub);
    header.appendChild(left);

    if (fullscreenSpec) {
      const fsBtn = document.createElement("button");
      fsBtn.className = "shrink-0 rounded-lg border border-gray-300 bg-white px-2.5 py-1.5 text-xs font-medium hover:bg-gray-50 active:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-300";
      fsBtn.textContent = "Full screen";
      fsBtn.addEventListener("click", () => openFullscreen(fullscreenSpec));
      header.appendChild(fsBtn);
    }

    const body = document.createElement("div");
    // Max height + scrollable body
    body.className = "p-3 md:p-4 overflow-auto scrollbar max-h-[65vh] min-h-[40vh] bg-gray-50";
    body.appendChild(contentNode);

    card.appendChild(header);
    card.appendChild(body);
    return card;
  }

  function makeIframe() {
    const iframe = document.createElement("iframe");
    iframe.className = "w-full h-[65vh] bg-white rounded-lg border border-gray-200";
    iframe.setAttribute("title", "Preview");
    // Keep it fairly permissive for HTML previews that include inline scripts/styles
    iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
    return iframe;
  }

  function makePre(text) {
    const pre = document.createElement("pre");
    pre.className = "whitespace-pre-wrap break-words text-xs font-mono text-gray-800";
    pre.textContent = text || "";
    return pre;
  }

  function renderPreviewForKey(key, value) {
    const detected = detectPayload(value);

    if (detected.kind === "html") {
      const iframe = makeIframe();
      iframe.srcdoc = detected.html || "";
      return createCard({
        title: key,
        subtitle: detected.mode === "base64" ? "HTML (base64)" : "HTML",
        contentNode: iframe,
        fullscreenSpec: { type: "html", title: key, subtitle: detected.mode === "base64" ? "HTML (base64)" : "HTML", srcdoc: detected.html || "" }
      });
    }

    if (detected.kind === "pdf") {
      const blob = new Blob([detected.bytes], { type: "application/pdf" });
      const url = URL.createObjectURL(blob);
      activeBlobUrls.push(url);

      const iframe = makeIframe();
      // PDF viewers are scrollable inside the iframe.
      iframe.removeAttribute("sandbox");
      iframe.src = url;

      return createCard({
        title: key,
        subtitle: "PDF (base64)",
        contentNode: iframe,
        // IMPORTANT: fullscreen must use the same blob URL as the inline preview.
        // Using srcdoc here would render a blank iframe instead of the PDF.
        fullscreenSpec: { type: "pdf", title: key, subtitle: "PDF (base64)", src: url }
      });
    }

    if (detected.kind === "bytes") {
      const pre = makePre(detected.textPreview || "(binary payload)");
      return createCard({
        title: key,
        subtitle: "Binary (base64) — showing text preview",
        contentNode: pre,
        fullscreenSpec: { type: "text", title: key, subtitle: "Binary (base64) — showing text preview", text: detected.textPreview || "(binary payload)" }
      });
    }

    if (detected.kind === "text") {
      const pre = makePre(detected.textPreview || "");
      return createCard({
        title: key,
        subtitle: detected.mode === "base64" ? "Text (base64 decoded)" : "Text",
        contentNode: pre
      });
    }

    if (detected.kind === "empty") {
      const pre = makePre("(empty)");
      return createCard({ title: key, subtitle: "Empty", contentNode: pre });
    }

    const pre = makePre(
      detected.reason ? `(${detected.reason})` : "(Unsupported value type)"
    );
    return createCard({ title: key, subtitle: "Unsupported", contentNode: pre, fullscreenSpec: { type: "text", title: key, subtitle: "Unsupported", text: pre.textContent || "" } });
  }

  function handleParse() {
    setError("");

    const jsonStr = els.jsonInput.value || "";
    const keysRaw = els.keysInput.value || "";

    if (!jsonStr.trim()) {
      setError("Response JSON is empty");
      clearCarousel();
      return;
    }

    let parsed;
    try {
      parsed = JSON.parse(jsonStr);
    } catch {
      setError("Invalid JSON");
      clearCarousel();
      return;
    }

    const keys = parseKeys(keysRaw);
    if (keys.length === 0) {
      setError("Add at least one key to preview");
      clearCarousel();
      return;
    }

    revokeAllBlobs();
    els.carousel.innerHTML = "";

    let renderedCount = 0;

    keys.forEach((k) => {
      const v = getByPath(parsed, k);
      const card = renderPreviewForKey(k, v);
      els.carousel.appendChild(card);
      renderedCount++;
    });  }

  // -------------------------
  // Events
  // -------------------------
  els.parseBtn.addEventListener("click", handleParse);
  els.clearBtn.addEventListener("click", () => {
    els.jsonInput.value = "";
    els.keysInput.value = "";
    setError("");
    clearCarousel();
  });


  // Fullscreen modal controls
  els.fullscreenClose.addEventListener("click", closeFullscreen);
  els.fullscreenBackdrop.addEventListener("click", closeFullscreen);
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && !els.fullscreenModal.classList.contains("hidden")) {
      closeFullscreen();
    }
  });


  // Initialize
  window.addEventListener("load", () => {
    clearCarousel();
  });
</script>
</body>
</html>
